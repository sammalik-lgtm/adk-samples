# CaMeL-Powered Secure Agent Demo with ADK
### Overview
This demo showcases an Agent Development Kit (ADK) implementation that leverages the CaMeL framework for enhanced security and controlled data flow in LLM agents. CaMeL (Defeating Prompt Injections by Design) provides a robust defense against prompt injection attacks by explicitly separating control and data flows within the agent. This ensures that untrusted data cannot compromise the agent's intended execution path. Additionally, CaMeL allows for the definition of precise rules that are consistently enforced over data flows between tool calls. This demo is not for production usage and in strictly intended for research-oriented purposes.

### Agent Details
The system leverages CaMeL, specified in [this paper](https://arxiv.org/abs/2503.18813), for secure execution and data flow management.

#### Agent Architecture
This diagram shows the detailed architecture of the agents and tools used to implement this workflow:

![CaMeL Workflow](<camel.png>)

The system is composed of the following agents, each with a specific responsibility:

| Feature | Description |
| --- | --- |
| *QLLM* | LlmAgent that operates on stateless interactions to extract structured information from unstructured inputs |
| *QuarantinedLlmService* | Wrapper service to manage and isolate interactions with the QLLM Agent |
| *CaMeLInterpreterService* | Service that manages interactions with the interpreter that runs generated code. It has access to a *QuarantinedLlmService* to make stateless calls to the *QLLM* agent. |
| *CaMeLInterpreter* | BaseAgent wrapper around the *CaMeLInterpreterService* for integration with ADK |
| *PLLM* | LlmAgent that generated code to fulfill user's request |
| **CaMeLAgent** | A loop agent that comprises of a *PLLM* and a *CaMeLInterpreter* |
  


The CaMeL agent architecture is designed for the reliable and secure execution of complex tasks by leveraging a combination of Large Language Models (LLMs) and a sandboxed code interpreter. The system employs a multi-agent paradigm, orchestrating interactions between several specialized agents to achieve a desired outcome. Emphasis is placed on controlled execution, data integrity, and adherence to predefined security policies.

**Quarantined LLM (QLLM):**

- An `LlmAgent` designed for the extraction of structured data from unstructured text.
- It operates in a "quarantined" manner; each interaction does not retain state.


**QuarantinedLlmService:** 

- A wrapper service that manages and isolates interactions with the `QLLM`.
- It handles the creation and deletion of sessions for each query to the QLLM, guaranteeing the stateless behavior of the QLLM.
- It exposes a `query_ai_assistant` function/tool, enabling the *soon to be mentioned* interpreter to invoke it for data extraction.

  
**CaMeLInterpreterService:**

- A centralized service responsible for the execution of Python code by providing an `execute_code` method, which parses, interprets, and executes Python code.
- It maintains a custom `namespace` encapsulating all accessible tools and functions, including the `query_ai_assistant` tool provided by a  QuarantinedLlmService instance.
- The custom CaMeL interpreter manages the dependencies, information flow,  and the state of the code execution.
- It enforces a configurable security policy, restricting the actions that generated code can perform.


**CaMeLInterpreter:**

- A `BaseAgent` that acts as a wrapper around the CaMeLInterpreterService.
- It receives code generated by the PLLM, delegates execution to the CaMeLInterpreterService, and reports the results.

  
**PLLM:**

- An `LlmAgent` tasked with generating Python code tailored to fulfill user requests.
- It operates based on a system prompt that describes available tools and functions.
- It generates code that can be executed by the `CaMeLInterpreter` to complete the user's request.

  
**CaMeLAgent:**

- A high-level ADK agent that orchestrates the overall process.
- It utilizes a `LoopAgent` to iteratively call the `PLLM` and the `CaMeLInterpreter`, continuing until a successful execution or a predefined limit of iterations is reached.
- It incorporates a `SecurityPolicyEngine` to ensure the safety of code generated and executed.
- It handles exceptions, including security policy violations, and provides meaningful feedback to the user.


#### Interaction Flow

The agent operates in a cyclical manner:

1. The agent receives a user's request.
2. The PLLM generates Python code based on the request and available tools, then saves the code to session state
3. The CaMeLInterpreter reads the code from session state, and passes it to the `CaMeLInterpreterService` for execution.
    a. QLLM Invocation: If necessary, the generated code can invoke the `query_ai_assistant` function to extract structured information using the QLLM.
    b. The interpreter will invoke the provided `SecurityPolicyEngine` before each tool call to ensure compliant code execution.
4. The CaMeLAgent decides whether to terminate the process - upon success or reaching a maximum number of iterations - or to continue with new code generation.

  
#### Security Considerations

1. Code Isolation: The CaMeLInterpreterService executes code within a sandboxed environment, preventing unauthorized access to the system.
2. Capability-Based Security: A SecurityPolicyEngine enforces fine-grained control over the capabilities of the generated code, preventing potential exploits.
3. Stateless QLLM: The QLLM's stateless nature mitigates the risk of persistent vulnerabilities across multiple requests.
4. Input Validation: The system validates the output schema of the QLLM to prevent unexpected data types.
5. Exception Handling: Errors during code execution are managed and reported gracefully, avoiding unexpected failures.
