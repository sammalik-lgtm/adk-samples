# CaMeL-Powered Secure Agent Demo with ADK
### Overview
This demo showcases an Agent Development Kit (ADK) implementation that leverages the CaMeL framework for enhanced security and controlled data flow in LLM agents. CaMeL (Defeating Prompt Injections by Design) provides a robust defense against prompt injection attacks by explicitly separating control and data flows within the agent. This ensures that untrusted data cannot compromise the agent's intended execution path. Additionally, CaMeL allows for the definition of precise rules that are consistently enforced over data flows between tool calls. This demo is not for production usage and in strictly intended for research-oriented purposes.

### Agent Details
The system leverages CaMeL, specified in [this paper](https://arxiv.org/abs/2503.18813), for secure execution and data flow management.

#### Agent Architecture
This diagram shows the detailed architecture of the agents and tools used to implement this workflow:

<camel.png>

The system is composed of the following agents, each with a specific responsibility:

| Feature | Description |
| --- | --- |
| *QLLM* | LlmAgent that operates on stateless interactions to extract structured information from unstructured inputs |
| *QuarantinedLlmService* | Wrapper service to manage and isolate interactions with the QLLM Agent |
| *CaMeLInterpreterService* | Service that manages interactions with the interpreter that runs generated code. It has access to a *QuarantinedLlmService* to make stateless calls to the *QLLM* agent. |
| *CaMeLInterpreter* | BaseAgent wrapper around the *CaMeLInterpreterService* for integration with ADK |
| *PLLM* | LlmAgent that generated code to fulfill user's request |
| **CaMeLAgent** | A loop agent that comprises of a *PLLM* and a *CaMeLInterpreter* |
  


The CaMeL agent architecture is designed for the reliable and secure execution of complex tasks by leveraging a combination of Large Language Models (LLMs) and a sandboxed code interpreter. The system employs a multi-agent paradigm, orchestrating interactions between several specialized agents to achieve a desired outcome. Emphasis is placed on controlled execution, data integrity, and adherence to predefined security policies.

**Quarantined LLM (QLLM):**

- A stateless LLM service, specifically designed for the extraction of structured data from unstructured text.
It operates in a "quarantined" manner, meaning that each interaction is isolated and does not retain state from previous calls.
- This component is critical for parsing and transforming data output from tools into a format suitable for further processing.
- It exposes a `query_ai_assistant` function, enabling other components to invoke it for data extraction.


**QuarantinedLlmService:** 

- A wrapper service that manages and isolates interactions with the QLLM.
It handles the creation and deletion of sessions for each query, guaranteeing the stateless behavior of the QLLM.
- It provides a synchronous interface (run) for the QLLM, to allow its use within the synchronous CaMeL interpreter.
- It manages the asynchronous execution of the QLLM within a separate thread.

  
**CaMeLInterpreterService:**

- A centralized service responsible for the execution of Python code generated by the Planning LLM (PLLM).
It maintains a namespace encapsulating all accessible tools and functions, including a QuarantinedLlmService instance.
- It enforces a configurable security policy, restricting the actions that generated code can perform.
- It provides an execute_code method, which parses, interprets, and executes CaMeL code, updating its internal state.
- It manages the dependencies and the state of the code execution.

  
**CaMeLInterpreter:**
- A `BaseAgent` that acts as a wrapper around the CaMeLInterpreterService.
- It receives code generated by the PLLM, delegates execution to the CaMeLInterpreterService, and reports the results.
- It integrates seamlessly with the ADK framework, allowing for participation in complex multi-agent workflows.

  
**PLLM:**

- An LLM tasked with generating Python code tailored to fulfill user requests.
- It operates based on a system prompt that describes available tools and functions.
- It generates code that can be executed by the CaMeLInterpreter to complete the user's request.

  
**CaMeLAgent:**

- A high-level ADK agent that orchestrates the overall process.
- It utilizes a `LoopAgent` to iteratively call the `PLLM` and the `CaMeLInterpreter`, continuing until a successful execution or a predefined limit of iterations is reached.
- It incorporates a SecurityPolicyEngine to ensure the safety of code generated and executed.
- It handles exceptions, including security policy violations, and provides meaningful feedback to the user.


#### Interaction Flow

The agent operates in a cyclical manner:

1. Request Reception: The agent receives a user's request.
2. PLLM Code Generation: The PLLM generates Python code based on the request and available tools.
3. Code Interpretation and Execution: The CaMeLInterpreter receives the code, and passes it to the CaMeLInterpreterService for execution.
4. QLLM Invocation: If necessary, the generated code can invoke the query_ai_assistant function to extract structured information using the QLLM.
5. Output and State Update: The CaMeLInterpreterService executes the code, updates its internal state, and provides the output and any generated tool calls.
6. Loop Termination/Continuation: The CaMeLAgent decides whether to terminate the process (upon success or reaching a maximum number of iterations) or to continue with new code generation.
7. Security Enforcement: The CaMeLAgent ensures that all the code execution is compliant with the SecurityPolicyEngine.

  
#### Security Considerations

1. Code Isolation: The CaMeLInterpreterService executes code within a sandboxed environment, preventing unauthorized access to the system.
2. Capability-Based Security: A SecurityPolicyEngine enforces fine-grained control over the capabilities of the generated code, preventing potential exploits.
3. Stateless QLLM: The QLLM's stateless nature mitigates the risk of persistent vulnerabilities across multiple requests.
4. Input Validation: The system validates the output schema of the QLLM to prevent unexpected data types.
5. Exception Handling: Errors during code execution are managed and reported gracefully, avoiding unexpected failures.
